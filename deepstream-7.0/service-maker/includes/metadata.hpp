/*
 * SPDX-FileCopyrightText: Copyright (c) 2024 NVIDIA CORPORATION & AFFILIATES. All rights reserved.
 * SPDX-License-Identifier: LicenseRef-NvidiaProprietary
 *
 * NVIDIA CORPORATION, its affiliates and licensors retain all intellectual
 * property and proprietary rights in and to this material, related
 * documentation and any modifications thereto. Any use, reproduction,
 * disclosure or distribution of this material and related documentation
 * without an express license agreement from NVIDIA CORPORATION or
 * its affiliates is strictly prohibited.
 */

/**
 * @file
 * <b>Metadata manipulation interfaces </b>
 *
 * Metadata is carried by a buffer and is accessible via buffer probe or
 * data receiver
 *
 */
#ifndef NVIDIA_DEEPSTREAM_METADATA
#define NVIDIA_DEEPSTREAM_METADATA

#include <functional>
#include <memory>
#include <string>

#include "nvll_osd_struct.h"

namespace deepstream {

#define USER_METADATA_START = (4096 + 4096 + 1)

/**
 * @brief Metadata base class
 *
 * The clas is not supposed to be used directly except that users want
 * to create their own derived metadata class
 *
 **/
class Metadata {
 public:
  /** @brief Constructor through an opqaue pinter */
  Metadata(void* data);

  /** @brief Destructor */
  virtual ~Metadata();

  /** @brief operator to check if a metadata is void */
  virtual operator bool() { return data_ != nullptr; }

 protected:
  void* data_; //> opaque data pointer
};

/**
 * @brief metadata iterator template
 *
 * Template parameter T is one of the derived class of Metadata.
 * The template is used with those metadata which contains a list of sub-metadata
 *
 * */
template <typename T>
class AbstractIterator {
 public:
  /** @brief Construct an iterator for an iterable metadata */
  AbstractIterator(const T& data) : data_(data) {}

  /** @brief Destructor */
  virtual ~AbstractIterator() {}

  /** @brief Dereference the associated metadata */
  T& operator*() { return data_; }

  /** @brief Dereference the associated metadata as a pointer*/
  T* operator->() { return &data_; }

  /** @brief Directly access the associated metadata */
  T& get() { return data_; }

  /** @brief advances the iterator to access the next data */
  virtual AbstractIterator<T>& next() = 0;

  /** @brief check if the end is reached */
  virtual bool done() = 0;

  /** @brief check if two iterator point to the same position */
  virtual bool operator==(const AbstractIterator<T>& other) const = 0;

  /** @brief check if two iterator point to different position */
  bool operator!=(const AbstractIterator<T>& other) const {
    return !(*this == other);
  }

 protected:
  T data_;
};

/** @brief Base class of user defined metadata */
class UserMetadata : public Metadata {
 public:
  typedef std::unique_ptr<AbstractIterator<UserMetadata>> Iterator;

  /**
   * @brief Constructor through opaque data pointer
   *
   * By default an empty user metadata object is created.
   *
   */
  UserMetadata(void*);
  /** @brief Destructor */
  virtual ~UserMetadata();

  friend class BatchMetadata;
  friend class FrameMetadata;

 protected:
  void get_(void*&);
};

/** @brief Meta generated from a classifier */
class ClassifierMetadata : public Metadata {
public:
  typedef std::unique_ptr<AbstractIterator<ClassifierMetadata>> Iterator;

  /**
   * @brief Constructor through opaque data pointer
   *
   * By default an empty classifier metadata object is created.
   *
   */
  ClassifierMetadata(void* data = nullptr);
  /** @brief Destructor */
  virtual ~ClassifierMetadata();

  /** @brief Number of the lables generated by the classifier */
  unsigned int nLabels() const;
  /** @brief Identifying the unique component that generates the metadata */
  unsigned int uniqueComponentId() const;
  /** @brief Get the nth label */
  std::string getLabel(unsigned int nth) const;

};

/**
 * @brief Object metadata
 *
 * The metadata is for describing a detected object
 *
 **/
class ObjectMetadata : public Metadata {
 public:
  typedef std::unique_ptr<AbstractIterator<ObjectMetadata>> Iterator;

  /**
   * @brief Constructor through opaque data pointer
   *
   * By default an empty object metadata object is created.
   *
   */
  ObjectMetadata(void* data = nullptr);
  /** @brief Destructor */
  virtual ~ObjectMetadata();

  /** @brief Number to identify the unique component that generates the metadata */
  unsigned int uniqueComponentId() const;
  /** @brief Number to identify the class of the object */
  unsigned int classId() const;
  /** @brief Number to identify the object which is tracked in the scene */
  unsigned long  int objectId() const;
  /** @brief Confidence level */
  float confidence() const;
  /** @brief Confidence level from tracker */
  float trackerConfidence() const;
  /** @brief Bounding box of the object */
  NvOSD_RectParams rectParams() const;
  /** @brief Holds mask parameters for the object. This mask is overlayed on object */
  NvOSD_MaskParams maskParams() const;
  /** @brief Formated text description of the object, controlling osd display */
  NvOSD_TextParams textParams() const;
  /** @brief A string to describe the object class */
  std::string label() const;

  /** @brief Iterate the classifier metadata within it */
  unsigned int iterate(const std::function<void(const ClassifierMetadata&)>& func) const;
  /** @brief Get the iterator for object metadata within it */
  void initiateIterator(ClassifierMetadata::Iterator&) const;

  /** @brief Iterate the user metadata within it */
  unsigned int iterate(const std::function<void(const UserMetadata&)>& func) const;
  /** @brief Get the iterator for user metadata within it */
  void initiateIterator(UserMetadata::Iterator&) const;
};


class FrameMetadata;
/**
 * @brief User metadata for event message
 *
 * Objects can be attached to the event message meta for triggering an event
 * in "nvmsgconv" element.
 *
 **/
class EventMessageUserMetadata : public UserMetadata {
 public:
  EventMessageUserMetadata(void* data=nullptr);
  virtual ~EventMessageUserMetadata();

  /** @brief generate an event by attaching an object */
  void generate(
    const ObjectMetadata&,
    const FrameMetadata&,
    const std::string sensor="N/A",
    const std::string uri="N/A",
    const std::vector<std::string>labels=std::vector<std::string>());
};

/**
 * @brief Template for customized user metadata
 *
 * Custom objects can be attached to user metadata via this template
 *
 **/
template <class C>
class UserMetadataTemplate : public UserMetadata {
 public:
  UserMetadataTemplate(void* data=nullptr) : UserMetadata(data) {}
  UserMetadataTemplate(const UserMetadata& other): UserMetadata(other) {}
  virtual ~UserMetadataTemplate() {}

  C& get() {
    void* p = nullptr;
    this->get_(p);
    return *((C*)p);
  }

  static void* copy(void* data, void* user_data) {
    void* p = nullptr;
    UserMetadataTemplate<C>(data).get_(p);
    C*& src = (C*&) p;
    C* dst = new C(*src);
    return dst;
  }

  static void free(void* data, void* user_data) {
    void* p = nullptr;
    UserMetadataTemplate<C>(data).get_(p);
    C*& src = (C*&) p;
    delete src;
    p = nullptr;
  }
};

/**
 * @brief Metadata for overlay display on a frame
 *
 * The metadata is for nvosd element display various shapes on the curernt
 * frame.
 *
 **/
class DisplayMetadata : public Metadata {
 public:
  typedef std::unique_ptr<AbstractIterator<DisplayMetadata>> Iterator;

  /**
   * @brief Constructor through opaque data pointer
   *
   * By default an empty display metadata object is created.
   *
   */
  DisplayMetadata(void* data = nullptr);
  /** @brief Destructor */
  virtual ~DisplayMetadata();

  /** @brief Number of the rectangles */
  unsigned int nRects() const;
  /** @brief Number of the labels */
  unsigned int nLabels() const;
  /** @brief Number of the lines */
  unsigned int nLines() const;
  /** @brief Number of the arrows */
  unsigned int nArrows() const;
  /** @brief Number of the circles */
  unsigned int nCircles() const;

  /** @brief Add a text label */
  bool add(NvOSD_TextParams&);
  /** @brief Add a rectangle */
  bool add(NvOSD_RectParams&);
  /** @brief Add a line */
  bool add(NvOSD_LineParams&);
  /** @brief Add an arrow */
  bool add(NvOSD_ArrowParams&);
  /** @brief Add a circle */
  bool add(NvOSD_CircleParams&);

  friend class FrameMetadata;
};

/**
 * @brief Holds information for a single frame.
 *
 * Iterable via iterators for ObjectMetadata and DisplayMetadata.
 *
 */
class FrameMetadata : public Metadata {
 public:
  typedef std::unique_ptr<AbstractIterator<FrameMetadata>> Iterator;

  /**
   * @brief Constructor through opaque data pointer
   *
   * By default an empty frame metadata object is created.
   *
   */
  FrameMetadata(void* data=nullptr);
  /** @brief Destructor */
  virtual ~FrameMetadata();

  /** @brief Iterate the object metadata within it */
  unsigned int iterate(const std::function<void(const ObjectMetadata&)>& func) const;
  /** @brief Get the iterator for object metadata within it */
  void initiateIterator(ObjectMetadata::Iterator&) const;

  /** @brief Iterate the display metadata within it */
  unsigned int iterate(const std::function<void(const DisplayMetadata&)>& func) const;
  /** @brief Get the iterator for display metadata within it */
  void initiateIterator(DisplayMetadata::Iterator&) const;

  /** @brief Index of the pad from which the frame is generated */
  unsigned int padIndex() const;
  /** @brief Location the frame in the batch */
  unsigned int batchId() const;
  /** @brief Frame number */
  int frameNum() const;
  /** @brief Identify the source of the frame, e.g. camera ID */
  unsigned int sourceId() const;
  /** @brief Picture width of the source */
  unsigned int sourceWidth() const;
  /** @brief Picture height of the source */
  unsigned int sourceHeight() const;

  /** @brief Picture width of the pipeline */
  unsigned int pipelineWidth() const;
  /** @brief Picture height of the pipeline */
  unsigned int pipelineHeight() const;

  /** Holds the presentation timestamp (PTS) of the frame. */
  uint64_t bufferPTS() const;
  /** Holds the ntp timestamp. */
  uint64_t ntpTimestamp() const;

  /** @brief Append an display metadata to the frame */
  void append(const DisplayMetadata&);
  /** @brief Append an user metadata to the frame */
  void append(const UserMetadata&);

  friend class BatchMetadata;
};

/**
 * @brief Holds information about a formed batch containingframes from different sources.
 *
 * Iterable via iterators for FrameMetadata and UserMetadata.
 * Support initiaizing sub-metadata including DisplayMetadata, FrameMetadata, ObjectMetadata,
 * EventMessageUserMetadata via acquire method. The aquired metadata objects are set to the
 * default state and the their lifecycle would be managed by the batch metadata automatically.
 *
 */
class BatchMetadata : public Metadata {
 public:
  /**
   * @brief Constructor through opaque data pointer
   *
   * By default an empty batch metadata object is created.
   *
   */
  BatchMetadata(void *data = nullptr);

  /** @brief Destructor */
  virtual ~BatchMetadata();

  /** @brief Iterate the frame metadata within it */
  unsigned int iterate(const std::function<void(const FrameMetadata&)>& func) const;
  /** @brief Get the iterator for frame metadata within it */
  void initiateIterator(FrameMetadata::Iterator&) const;

  /** @brief Iterate the user metadata within it */
  unsigned int iterate(const std::function<void(const UserMetadata&)>& func) const;
  /** @brief Get the iterator for user metadata within it */
  void initiateIterator(UserMetadata::Iterator&) const;

  /** @brief Initialize an empty display metadata */
  bool acquire(DisplayMetadata&);
  /** @brief Initialize an empty frame metadata */
  bool acquire(FrameMetadata&);
  /** @brief Initialize an empty object metadata */
  bool acquire(ObjectMetadata&);
  /** @brief Initialize an empty event message user metadata */
  bool acquire(EventMessageUserMetadata&);
  /** @brief Initialize an empty user metadata through template */
  template<class C>
  bool acquire(UserMetadataTemplate<C>& user_meta) {
    user_meta = acquireUserMetadata_(
        new C, C::getDsMetaType(), UserMetadataTemplate<C>::copy, UserMetadataTemplate<C>::free
    );
    return user_meta ? true : false;
  }

  /** @brief Append a frame metadata to the batch */
  void append(const FrameMetadata&);
  /** @brief Append a user metadata to the batch */
  void append(const UserMetadata&);

  /** @brief Number of frames in the batch*/
  unsigned int nFrames() const;

 protected:
  UserMetadata acquireUserMetadata_(
    void* data, unsigned int type, void*(*copy)(void*, void*), void(*free)(void*, void*)
  );
};

}

#endif